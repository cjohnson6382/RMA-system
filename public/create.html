//  design: main page will start off showing 10-15 most recent tickets (user-selected?)
//      below will be a 'create' button
//      hovering over an item on the list will show a 'delete' button
//      next to the create button will be a text box for filtering the recent tickets display
//          the left side of the textbox will have checkboxes like amazon or ebay

//      clicking on a list item will open a modal or something with a summary of the item's properties
//          the summary page will let you edit fields

//      what's the summary page going to look like?
//          I think I'm just gonna have to fuck around with this; I can probably fit all the information
//              under headings, but it's not gonna be super easy to find a given field
//              maybe links to anchors on the page....

//  I need a ticket template to use to build tickets... this will be an object on the server
//      it'll get pulled down when you create a new ticket

//  the summary page will have multiple modules that'll differ only in their layout
//      but I need some kind of consistent way of laying out modules
//      assign a priority weight to each field and have the fields render according to it?
//          highest priority goes at the top left corner and have one item per line?
//      the ticket template can come with field priority on it, or layout information generally





//  need to create an authentication system that checks against the database before allowing people to mess with the system

//  RMA properties: ID (int), date (of RMA ticket creation?) (date), type (text), customer (text), drop ship (checkbox), write touch pos???, 

//      inventory: item number (int), vendor (text), serial number (int), purchase date (date), RMA type (subfields are textfields) [doa - cross ship, doa - repair & return, non-warranty - repair & return, other - see notes, return - credit, warranty - cross ship, warranty - repair & return], invoice (int), problem (textbox)
//      customer: NO INFORMATION ON THIS TAB
//      status: rma status (subfields) [item number (int), received (date). tracking # (int), eval (checkbox), stock (checkbox), clos? (checkbox)]
//      other: started by (text?), notes (textbox), hold status (subfields) [item number (int), repair hold (checkbox), hold date (date), vender RMA (int?)]

//  side bar: request, issue, receive, cancel, >|

const CreateTicket = React.crateClass({
    
});

const UpdateTicket = React.crateClass({
    
});

//  this is both for creating new tickets and for updating existing tickets
//      if I'm creating a new ticket, I need to initialize it to empty
//      if I'm updating an existing ticket, I need to fill all its values in
//          but the values have to be states and not props so that I can modify them

//  initialize to empty, when component loads if update then populate
//      how do you initialize a ticket with props and then update with states?

//  create is easy; you just initialize to empty and then collect any fields the user modifies in a state
//      when the user submits the ticket you can just send the state to the server or to an intermediate flux dispatcher

//  modify should be similarly easy; you populate all the fields in a ticket
//      when the user modifies a field, put the modification in the state
//      construct an update object from the state and send it to the server

//  how do you make the TicketBox class work for both ceate and update?
//      determine whether it has a ticket prop; if it does, populate the fields; otherwise initialize an empty

//  do I need to update the state of the ticketbox at any time?
//      I'm using state to get 


const CommentBox = React.createClass({
    handleCommentSubmit: function (comment) {
    
        $.post(this.props.source, comment, function (data) {
            this.setState({ data: data });
        }.bind(this));
    },
    getInitialState: function () {
        return { data: [] };
    },
    
    loadCommentsFromServer: function () {
        $.get(this.props.source, function (data) {
            this.setState({ data: data });
        }.bind(this));                

    },
    
    componentDidMount: function () {
        this.loadCommentsFromServer();
        setInterval(this.loadCommentsFromServer, this.props.pollInterval);
    },

    render: function () {
        return (
            <div className="commentBox">
                Hellooooo world
                <h1>Comments</h1>
                <CommentList data={ this.state.data } />
                <CommentForm onCommentSubmit={ this.handleCommentSubmit } />
            </div>
        );
    }
});

//  this is for listing the tickets
//      needs to have some controls that let you filter results and specifiy how many results to return?
//  it might be easier to just have this be a google search-type interface that lets you search for a ticket
//      by default display the last 15 tickets and the search box will hit the server with the search you provide

const CommentList = React.createClass({
    render: function () {
        const commentNodes = this.props.data.map(function (comment) {
            return (
                <Comment author={comment.author} key={comment.id}>
                    {comment.text}
                </Comment>
            );
        });
        
        return (
            <div className="commentList">
                {commentNodes}
            </div>
        );
    }
});

const CommentForm = React.createClass({
    getInitialState: function () {
        return {author: '', text: ''};
    },

    handleAuthorChange: function (e) {
        this.setState({ author: e.target.value });
    },
    
    handleCommentChange: function (e) {
        this.setState({ text: e.target.value });
    },

    handleSubmit: function (e) {
        //  browser's default action is to actually submit the form, which we don't want
        e.preventDefault();
        
        const author = this.state.author.trim();
        const text = this.state.text.trim();
        
        if (!text || !author) {
            return;
        }
        
        this.props.onCommentSubmit({ author: author, text: text });
        //  clear the form
        this.setState({ author: '', text: ''});
    },

    render: function () {
        return (
            <div>
                <h3>Add a new comment</h3>
                <form className="commentForm" onSubmit={this.handleSubmit} >
                    <input type="text" placeholder="Name" value={this.state.author} onChange={this.handleAuthorChange} />
                    <input type="text" placeholder="Comment" value={this.state.text} onChange={this.handleCommentChange} />
                    <input type="submit" value="Post" />
                </form>
            </div>
        );
    }
});

const Comment = React.createClass({
    rawMarkup: function () {
        const md = new Remarkable();
        const rawMarkup = md.render(this.props.children.toString());
        return { __html: rawMarkup };
    },

    render: function () {
        return (
            <div className="comment">
                <h2 className="commentAuthor">
                    {this.props.author}
                </h2>
                <span dangerouslySetInnerHTML = {this.rawMarkup() }/>
            </div>
        );
    }
});

ReactDOM.render(
    <CommentBox source="http://cjohnson.ignorelist.com/api/comments" pollInterval={2000}/>,
    document.getElementById('content')
);